// Волновой алгоритм — это метод поиска кратчайшего пути в графе, который часто используется для
// поиска пути на сетке, такой как карта или лабиринт. Этот алгоритм работает по принципу волны,
// постепенно "распространяясь" от начальной точки в соседние вершины.
// ### Описание Алгоритма
// - **Инициализация**: Создайте очередь для хранения вершин, которые должны быть обработаны.
// Также создайте двумерный массив для хранения расстояний от стартовой точки до каждой точки.
// - **Фаза обработки**: Извлекайте вершины из очереди, проверяйте их соседей и обновляйте расстояния
// до них, добавляя их в очередь, если они не были посещены.
// - **Завершение**: Процесс продолжается до тех пор, пока не будут обработаны все reachable
// вершины или пока не достигнется целевая вершина.
// ### Пример Реализации на C
// Вот пример реализации волнового алгоритма на языке C, предполагающий, что граф представлен в
// виде матрицы смежности:

// ```
#include <stdio.h>
#include <stdlib.h>

#define MAX 100   // Максимальное количество вершин
#define INF 99999 // Бесконечность (когда нет пути)

int graph[MAX][MAX];     // Матрица смежности
int distance[MAX];       // Массив для хранения расстояний
int visited[MAX];        // Массив для отслеживания посещённых вершин
int queue[MAX];          // Очередь для обработки вершин
int front = 0, rear = 0; // Переменные для использования очереди

void enqueue(int node)
{
    queue[rear++] = node;
}

int dequeue()
{
    return queue[front++];
}

int isEmpty()
{
    return front == rear;
}

void waveAlgorithm(int start, int end, int n)
{
    for (int i = 0; i < n; i++)
    {
        distance[i] = INF; // Инициализация расстояний бесконечностью
        visited[i] = 0;    // Инициализация всех вершин как непосещённых
    }

    distance[start] = 0; // Расстояние до стартовой вершины равно 0
    enqueue(start);      // Добавляем стартовую вершину в очередь

    while (!isEmpty())
    {
        int current = dequeue(); // Извлекаем вершину из очереди
        visited[current] = 1;    // Помечаем её как посещённую

        // Обрабатываем соседние вершины
        for (int i = 0; i < n; i++)
        {
            if (graph[current][i] != 0 && !visited[i])
            { // Если есть связь и не посещено
                if (distance[current] + graph[current][i] < distance[i])
                {
                    distance[i] = distance[current] + graph[current][i]; // Обновляем кратчайшее расстояние
                }

                enqueue(i); // Добавляем эту вершину в очередь
            }
        }
    }

    // Печатаем результат
    printf("Кратчайшие расстояния от вершины %d:\n", start);
    for (int i = 0; i < n; i++)
    {
        if (distance[i] == INF)
            printf("Вершина %d недостижима\n", i);
        else
            printf("Вершина %d: %d\n", i, distance[i]);
    }
}

int main()
{
    int n; // Количество вершин
    printf("Введите количество вершин: ");
    scanf("%d", &n);

    printf("Заполните матрицу смежности (0, если нет ребра):\n");
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            scanf("%d", &graph[i][j]);
        }
    }

    int start, end;
    printf("Введите начальную вершину: ");
    scanf("%d", &start);
    printf("Введите конечную вершину: ");
    scanf("%d", &end);

    waveAlgorithm(start, end, n); // Запускаем алгоритм

    return 0;
}
// ```

//     ## #Объяснение Кода :

//     -**Структура Данных ** :

//     -graph[MAX][MAX] : Матрица смежности для представления графа.

//     - distance[MAX] : Для хранения кратчайших расстояний.

//     - visited[MAX] : Чтобы отслеживать,
//     какие вершины были посещены.

//         - queue[MAX] : Для реализации очереди.

//         - **Функции Очереди ** :

//     -enqueue(),
//     dequeue(), и isEmpty() для управления очередью.

//                    - **Основной Алгоритм ** :

//     -Проход с использованием очереди для поиска кратчайшего пути,
//     обновление текущих расстояний.

//         - При завершении выводится кратчайшее расстояние до всех вершин из стартовой.

//           Вы можете использовать данный код,
//     чтобы легко найти кратчайший путь в графе, задав входные данные в виде матрицы смежности.